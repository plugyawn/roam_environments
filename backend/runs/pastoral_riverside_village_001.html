<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Scene Viewer - pastoral_riverside_village_001</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <style>
                html, body { margin: 0; height: 100%; }
                body { position: relative; background: #0f172a; color: #f8fafc; }
                #viewer { width: 100%; height: 100%; display: block; }
                #overlay { position: absolute; top: 12px; left: 12px; padding: 8px 12px; background: rgba(12, 18, 33, 0.78); border-radius: 6px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; box-shadow: 0 6px 18px rgba(5, 10, 25, 0.45); }
                #overlay span { display: block; font-size: 14px; letter-spacing: 0.03em; opacity: 0.9; }
        </style>
</head>
<body>
        <canvas id="viewer"></canvas>
        <div id="overlay">
                <strong>Scene:</strong> <span>pastoral_riverside_village_001</span>
        </div>
        <script id="manifest-data" type="application/json">{"scene_id":"pastoral_riverside_village_001","prompt":"Design a pastoral riverside village with a market square","requirements":{"requirements":[{"concept":"market_square","min_count":1},{"concept":"river","min_count":1},{"concept":"cottage","min_count":1},{"concept":"cottage","min_count":1},{"concept":"barn","min_count":1},{"concept":"silo","min_count":1},{"concept":"church","min_count":1},{"concept":"bridge","min_count":1},{"concept":"market_stall","min_count":1},{"concept":"market_stall","min_count":1},{"concept":"fountain","min_count":1},{"concept":"water_well","min_count":1},{"concept":"tree","min_count":1},{"concept":"tree","min_count":1},{"concept":"fence","min_count":1},{"concept":"wagon","min_count":1}]},"scene_spec":{"theme":"pastoral riverside village","setting":"European-inspired rural village","scale":"small village (500-1000 residents)","key_elements":["meandering river with gentle banks","cobblestone market square with fountain","thatched cottages and stone buildings","wooden market stalls","agricultural structures (barn, silo)","village church with bell tower","stone bridge crossing river","cobblestone streets and pathways","mature trees and green spaces","wooden fences and garden borders"],"entities":[{"concept":"market_square","count":1,"attrs":{}},{"concept":"river","count":1,"attrs":{}},{"concept":"cottage","count":1,"attrs":{}},{"concept":"cottage","count":1,"attrs":{}},{"concept":"barn","count":1,"attrs":{}},{"concept":"silo","count":1,"attrs":{}},{"concept":"church","count":1,"attrs":{}},{"concept":"bridge","count":1,"attrs":{}},{"concept":"market_stall","count":1,"attrs":{}},{"concept":"market_stall","count":1,"attrs":{}},{"concept":"fountain","count":1,"attrs":{}},{"concept":"water_well","count":1,"attrs":{}},{"concept":"tree","count":1,"attrs":{}},{"concept":"tree","count":1,"attrs":{}},{"concept":"fence","count":1,"attrs":{}},{"concept":"wagon","count":1,"attrs":{}}],"constraints":[]},"assets":[{"id":"market_square_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/market_square_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"market_square","w":1.0,"h":1.0,"d":1.0}],"materials":{"market_square":"default_grey"},"id":"market_square_01","tags":["market_square","market_square_01"]}},{"id":"river_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/river_01.glb","bbox":[20.0,0.010000000000000009,200.0],"recipe":{"recipe":[{"primitive":"plane","name":"surface","w":20,"d":200,"offset":[0,-0.2,0]}],"materials":{"surface":"water_blue"},"id":"river_01","tags":["river","river_01"]}},{"id":"cottage_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/cottage_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"cottage","w":1.0,"h":1.0,"d":1.0}],"materials":{"cottage":"default_grey"},"id":"cottage_01","tags":["cottage","cottage_01"]}},{"id":"cottage_02","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/cottage_02.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"cottage","w":1.0,"h":1.0,"d":1.0}],"materials":{"cottage":"default_grey"},"id":"cottage_02","tags":["cottage","cottage_02"]}},{"id":"barn_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/barn_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"barn","w":1.0,"h":1.0,"d":1.0}],"materials":{"barn":"default_grey"},"id":"barn_01","tags":["barn","barn_01"]}},{"id":"silo_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/silo_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"silo","w":1.0,"h":1.0,"d":1.0}],"materials":{"silo":"default_grey"},"id":"silo_01","tags":["silo","silo_01"]}},{"id":"church_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/church_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"church","w":1.0,"h":1.0,"d":1.0}],"materials":{"church":"default_grey"},"id":"church_01","tags":["church","church_01"]}},{"id":"bridge_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/bridge_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"bridge","w":1.0,"h":1.0,"d":1.0}],"materials":{"bridge":"default_grey"},"id":"bridge_01","tags":["bridge","bridge_01"]}},{"id":"market_stall_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/market_stall_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"market_stall","w":1.0,"h":1.0,"d":1.0}],"materials":{"market_stall":"default_grey"},"id":"market_stall_01","tags":["market_stall","market_stall_01"]}},{"id":"market_stall_02","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/market_stall_02.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"market_stall","w":1.0,"h":1.0,"d":1.0}],"materials":{"market_stall":"default_grey"},"id":"market_stall_02","tags":["market_stall","market_stall_02"]}},{"id":"fountain_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/fountain_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"fountain","w":1.0,"h":1.0,"d":1.0}],"materials":{"fountain":"default_grey"},"id":"fountain_01","tags":["fountain","fountain_01"]}},{"id":"water_well_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/water_well_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"water_well","w":1.0,"h":1.0,"d":1.0}],"materials":{"water_well":"default_grey"},"id":"water_well_01","tags":["water_well","water_well_01"]}},{"id":"tree_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/tree_01.glb","bbox":[5.0,7.4,5.0],"recipe":{"recipe":[{"primitive":"cylinder","name":"trunk","r":0.4,"h":4.5},{"primitive":"sphere","name":"crown","r":2.5,"offset":[0,4.5,0]}],"materials":{"trunk":"bark_brown","crown":"leaf_green"},"id":"tree_01","tags":["tree","tree_01"]}},{"id":"tree_02","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/tree_02.glb","bbox":[5.0,7.4,5.0],"recipe":{"recipe":[{"primitive":"cylinder","name":"trunk","r":0.4,"h":4.5},{"primitive":"sphere","name":"crown","r":2.5,"offset":[0,4.5,0]}],"materials":{"trunk":"bark_brown","crown":"leaf_green"},"id":"tree_02","tags":["tree","tree_02"]}},{"id":"fence_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/fence_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"fence","w":1.0,"h":1.0,"d":1.0}],"materials":{"fence":"default_grey"},"id":"fence_01","tags":["fence","fence_01"]}},{"id":"wagon_01","glb_path":"/Users/plugyawn/bounties/roam_environments/backend/assets/wagon_01.glb","bbox":[1.0,1.0,1.0],"recipe":{"recipe":[{"primitive":"cuboid","name":"wagon","w":1.0,"h":1.0,"d":1.0}],"materials":{"wagon":"default_grey"},"id":"wagon_01","tags":["wagon","wagon_01"]}}],"map_plan":{"name":"Riverside Village Map","dimensions":{"width":120,"length":180,"height":30},"zones":[{"name":"market_square","type":"commercial","position":[60,0,90],"size":[40,0,40],"description":"Central cobblestone market square with fountain"},{"name":"residential_area","type":"residential","position":[30,0,50],"size":[50,0,70],"description":"Cluster of residential cottages with gardens"},{"name":"agricultural_zone","type":"agricultural","position":[90,0,40],"size":[30,0,60],"description":"Farm buildings and storage structures"},{"name":"river_front","type":"natural","position":[0,0,90],"size":[20,0,180],"description":"Riverbank area with willow trees"},{"name":"village_center","type":"landmark","position":[75,0,130],"size":[25,0,30],"description":"Village church and central gathering area"}]},"scene_graph":{"map":{"name":"Riverside Village Map","dimensions":{"width":120,"length":180,"height":30},"zones":[{"name":"market_square","type":"commercial","position":[60,0,90],"size":[40,0,40],"description":"Central cobblestone market square with fountain"},{"name":"residential_area","type":"residential","position":[30,0,50],"size":[50,0,70],"description":"Cluster of residential cottages with gardens"},{"name":"agricultural_zone","type":"agricultural","position":[90,0,40],"size":[30,0,60],"description":"Farm buildings and storage structures"},{"name":"river_front","type":"natural","position":[0,0,90],"size":[20,0,180],"description":"Riverbank area with willow trees"},{"name":"village_center","type":"landmark","position":[75,0,130],"size":[25,0,30],"description":"Village church and central gathering area"}]},"placements":[{"asset_id":"market_square_01","pos":[60,0,90],"rotY":0,"description":"Central market square","ref":"market_square_01"},{"asset_id":"river_01","pos":[10,0,90],"rotY":0,"description":"Main river flowing through village","ref":"river_01"},{"asset_id":"cottage_01","pos":[25,0,45],"rotY":0,"description":"Residential cottage near village entrance","ref":"cottage_01"},{"asset_id":"cottage_02","pos":[35,0,55],"rotY":1.57,"description":"Larger residential cottage with garden","ref":"cottage_02"},{"asset_id":"cottage_01","pos":[15,0,65],"rotY":3.14,"description":"Additional residential cottage","ref":"cottage_01"},{"asset_id":"cottage_02","pos":[45,0,35],"rotY":4.71,"description":"Corner residential cottage","ref":"cottage_02"},{"asset_id":"barn_01","pos":[95,0,45],"rotY":0,"description":"Main agricultural barn","ref":"barn_01"},{"asset_id":"silo_01","pos":[105,0,55],"rotY":0,"description":"Grain storage silo","ref":"silo_01"},{"asset_id":"church_01","pos":[75,0,135],"rotY":0,"description":"Village church with bell tower","ref":"church_01"},{"asset_id":"bridge_01","pos":[55,5,85],"rotY":1.57,"description":"Stone bridge crossing river","ref":"bridge_01"},{"asset_id":"market_stall_01","pos":[50,0,85],"rotY":0,"description":"Vegetable market stall","ref":"market_stall_01"},{"asset_id":"market_stall_02","pos":[70,0,85],"rotY":0,"description":"Bakery market stall","ref":"market_stall_02"},{"asset_id":"market_stall_01","pos":[60,0,100],"rotY":1.57,"description":"Additional market stall","ref":"market_stall_01"},{"asset_id":"fountain_01","pos":[60,0,90],"rotY":0,"description":"Central market square fountain","ref":"fountain_01"},{"asset_id":"water_well_01","pos":[40,0,95],"rotY":0,"description":"Village water well near market","ref":"water_well_01"},{"asset_id":"tree_01","pos":[20,0,40],"rotY":0,"description":"Mature oak tree in residential area","ref":"tree_01"},{"asset_id":"tree_02","pos":[15,0,90],"rotY":0,"description":"Willow tree along riverbank","ref":"tree_02"},{"asset_id":"tree_01","pos":[65,0,75],"rotY":0,"description":"Shade tree near market","ref":"tree_01"},{"asset_id":"fence_01","pos":[30,0,50],"rotY":0,"description":"Garden fence around cottage","ref":"fence_01"},{"asset_id":"wagon_01","pos":[52,0,88],"rotY":0.78,"description":"Market wagon near stalls","ref":"wagon_01"}],"scene_id":"pastoral_riverside_village_001","assets":["market_square_01","river_01","cottage_01","cottage_02","barn_01","silo_01","church_01","bridge_01","market_stall_01","market_stall_02","fountain_01","water_well_01","tree_01","tree_02","fence_01","wagon_01"]},"validation":{"status":"pass","issues":[],"metrics":{"concept_counts":{"market_square":1,"river":1,"cottage":4,"barn":1,"silo":1,"church":1,"bridge":1,"market_stall":3,"fountain":1,"water_well":1,"tree":3,"fence":1,"wagon":1}}}}</script>
<script>
    (function () {
        const overlay = document.getElementById('overlay');
        const displayedErrors = new Set();

        function reportError(message) {
            if (!message || displayedErrors.has(message)) {
                return;
            }
            displayedErrors.add(message);
            if (overlay) {
                const line = document.createElement('span');
                line.textContent = `Error: ${message}`;
                line.style.color = '#f87171';
                overlay.appendChild(line);
            } else {
                console.error(message);
            }
        }

        window.addEventListener('error', (event) => {
            if (event?.message) {
                reportError(event.message);
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            if (!event?.reason) {
                return;
            }
            if (event.reason instanceof Error) {
                reportError(event.reason.message);
            } else {
                reportError(String(event.reason));
            }
        });

        const THREE_SOURCES = [
            'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js',
            'https://unpkg.com/three@0.158.0/build/three.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js'
        ];

        function injectScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.crossOrigin = 'anonymous';
                script.onload = () => resolve(src);
                script.onerror = () => {
                    script.remove();
                    reject(new Error(`Failed to load ${src}`));
                };
                document.head.appendChild(script);
            });
        }

        async function ensureThree() {
            if (typeof window.THREE !== 'undefined') {
                return true;
            }
            for (const src of THREE_SOURCES) {
                try {
                    await injectScript(src);
                    if (typeof window.THREE !== 'undefined') {
                        return true;
                    }
                } catch (error) {
                    reportError(error instanceof Error ? error.message : String(error));
                }
            }
            reportError('THREE.js failed to load.');
            return false;
        }

        function normalizePlacements(rawPlacements) {
            return rawPlacements
                .map((placement) => {
                    const pos = placement.pos || placement.position || (placement.transform && placement.transform.pos);
                    if (!Array.isArray(pos) || pos.length < 3) {
                        return null;
                    }
                    const scale = placement.scale || (placement.transform && placement.transform.scale) || [1, 1, 1];
                    const rot = placement.rotY ?? (placement.rotation && placement.rotation.y) ?? (placement.transform && placement.transform.rot && placement.transform.rot[1]) ?? 0;
                    const id = placement.ref || placement.asset_id || placement.asset || placement.id || 'unknown';
                    const normalizedScale = Array.isArray(scale)
                        ? scale.slice(0, 3).map(Number)
                        : [Number(scale) || 1, Number(scale) || 1, Number(scale) || 1];
                    return {
                        id,
                        position: pos.slice(0, 3).map(Number),
                        scale: normalizedScale,
                        rotY: Number(rot) || 0,
                    };
                })
                .filter(Boolean);
        }

        async function init() {
            const threeReady = await ensureThree();
            if (!threeReady) {
                return;
            }

            const THREE = window.THREE;
            const manifestScript = document.getElementById('manifest-data');
            if (!manifestScript) {
                reportError('Missing manifest payload.');
                return;
            }

            let manifest = {};
            try {
                manifest = JSON.parse(manifestScript.textContent || '{}');
            } catch (error) {
                reportError(`Failed to parse manifest: ${error instanceof Error ? error.message : String(error)}`);
                return;
            }

            const placements = normalizePlacements(
                Array.isArray(manifest?.scene_graph?.placements) ? manifest.scene_graph.placements : []
            );
            const canvas = document.getElementById('viewer');
            if (!canvas) {
                reportError('Canvas element missing.');
                return;
            }

            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color('#a8bbd4');

            const camera = new THREE.PerspectiveCamera(
                48,
                window.innerWidth / Math.max(window.innerHeight, 1),
                0.1,
                2000
            );
            const controls = createSimpleOrbitControls(THREE, camera, renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(250, 400, 180);
            directional.castShadow = true;
            scene.add(directional);

            const grid = new THREE.GridHelper(600, 24, 0x223344, 0x556677);
            grid.position.y = 0;
            scene.add(grid);

            const colorCache = new Map();
            const palette = [0xd97093, 0x4169e1, 0x2e8b57, 0xc79343, 0x8a36bf, 0xcd5c5c, 0x4682b4, 0x8fbc8f, 0xd2b48c, 0x6495ed];

            placements.forEach((entry) => {
                let color = colorCache.get(entry.id);
                if (!color) {
                    color = palette[colorCache.size % palette.length];
                    colorCache.set(entry.id, color);
                }

                const width = entry.scale[0] || 4;
                const height = entry.scale[1] || 6;
                const depth = entry.scale[2] || 4;

                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({ color, metalness: 0.05, roughness: 0.65 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(entry.position[0], height * 0.5, entry.position[2]);
                mesh.rotation.y = THREE.MathUtils.degToRad(entry.rotY);
                mesh.castShadow = true;
                scene.add(mesh);

                const canvasLabel = document.createElement('canvas');
                canvasLabel.width = 256;
                canvasLabel.height = 128;
                const ctx = canvasLabel.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';
                    ctx.fillRect(0, 0, 256, 128);
                    ctx.fillStyle = '#f8fafc';
                    ctx.font = '24px sans-serif';
                    ctx.fillText(entry.id, 12, 72);
                    const texture = new THREE.CanvasTexture(canvasLabel);
                    texture.needsUpdate = true;
                    const materialLabel = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                    const sprite = new THREE.Sprite(materialLabel);
                    sprite.position.set(entry.position[0], height + 4, entry.position[2]);
                    sprite.scale.set(20, 10, 1);
                    scene.add(sprite);
                }
            });

            if (!placements.length) {
                reportError('No placements found in manifest. Showing grid only.');
            }

            const positions = placements.map((entry) => entry.position);
            const center = positions.reduce(
                (acc, pos) => [acc[0] + pos[0], acc[1] + pos[1], acc[2] + pos[2]],
                [0, 0, 0]
            );
            if (positions.length) {
                center[0] /= positions.length;
                center[1] /= positions.length;
                center[2] /= positions.length;
            }

            const radius = positions.reduce((max, pos) => {
                const dx = pos[0] - center[0];
                const dz = pos[2] - center[2];
                return Math.max(max, Math.sqrt(dx * dx + dz * dz));
            }, 60);

            camera.position.set(
                center[0] + radius * 1.4,
                center[1] + radius * 1.1 + 80,
                center[2] + radius * 1.4
            );
            controls.setTarget(center[0], center[1], center[2]);
            controls.setDistance(Math.max(radius * 1.4, 30));
            controls.syncFromCamera();

            function handleResize() {
                const width = window.innerWidth;
                const height = Math.max(window.innerHeight, 1);
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }

            window.addEventListener('resize', handleResize);
            handleResize();

            function animate() {
                controls.update();
                renderer.render(scene, camera);
                window.requestAnimationFrame(animate);
            }

            animate();
        }

        init();

        function createSimpleOrbitControls(THREE, camera, domElement) {
            const target = new THREE.Vector3();
            const spherical = new THREE.Spherical();
            const sphericalDelta = new THREE.Spherical();
            const pointer = new THREE.Vector2();
            const rotateStart = new THREE.Vector2();
            const rotateEnd = new THREE.Vector2();
            const rotateDelta = new THREE.Vector2();
            const panOffset = new THREE.Vector3();
            const panStart = new THREE.Vector2();
            const panEnd = new THREE.Vector2();
            const panDelta = new THREE.Vector2();
            const state = {
                isRotating: false,
                isPanning: false,
            };

            const controls = {
                target,
                enableDamping: true,
                dampingFactor: 0.08,
                rotateSpeed: 1.0,
                zoomSpeed: 1.0,
                panSpeed: 0.8,
                minDistance: 10,
                maxDistance: 1200,
                minPolarAngle: 0.01,
                maxPolarAngle: Math.PI - 0.01,
                update,
                dispose,
                setTarget(x, y, z) {
                    target.set(x, y, z);
                },
                setDistance(distance) {
                    spherical.radius = Math.max(controls.minDistance, Math.min(controls.maxDistance, distance));
                },
                syncFromCamera,
            };

            domElement.style.touchAction = 'none';

            function syncFromCamera() {
                const offset = new THREE.Vector3().copy(camera.position).sub(target);
                spherical.setFromVector3(offset);
                clampSpherical();
            }

            function onPointerDown(event) {
                if (event.pointerType === 'touch' && event.touches && event.touches.length > 1) {
                    return;
                }
                domElement.setPointerCapture?.(event.pointerId ?? 0);
                if (event.button === 1 || event.button === 2 || event.shiftKey) {
                    state.isPanning = true;
                    panStart.set(event.clientX, event.clientY);
                } else {
                    state.isRotating = true;
                    rotateStart.set(event.clientX, event.clientY);
                }
            }

            function onPointerMove(event) {
                if (state.isRotating) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(controls.rotateSpeed / 300);
                    sphericalDelta.theta -= rotateDelta.x;
                    sphericalDelta.phi -= rotateDelta.y;
                    rotateStart.copy(rotateEnd);
                } else if (state.isPanning) {
                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart).multiplyScalar(controls.panSpeed / 100);
                    pan(panDelta.x, panDelta.y);
                    panStart.copy(panEnd);
                }
            }

            function onPointerUp(event) {
                domElement.releasePointerCapture?.(event.pointerId ?? 0);
                state.isRotating = false;
                state.isPanning = false;
                sphericalDelta.set(0, 0, 0);
            }

            function onWheel(event) {
                event.preventDefault();
                const delta = Math.sign(event.deltaY);
                const factor = Math.pow(0.95, controls.zoomSpeed);
                if (delta > 0) {
                    spherical.radius = Math.min(controls.maxDistance, spherical.radius / factor);
                } else if (delta < 0) {
                    spherical.radius = Math.max(controls.minDistance, spherical.radius * factor);
                }
            }

            function pan(deltaX, deltaY) {
                const offset = new THREE.Vector3().copy(camera.position).sub(target);
                const targetDistance = offset.length();
                const panLeft = new THREE.Vector3();
                const panUp = new THREE.Vector3();
                panLeft.setFromMatrixColumn(camera.matrix, 0);
                panUp.setFromMatrixColumn(camera.matrix, 1);
                panLeft.multiplyScalar(-deltaX * targetDistance);
                panUp.multiplyScalar(deltaY * targetDistance);
                panOffset.copy(panLeft).add(panUp);
                target.add(panOffset);
                camera.position.add(panOffset);
                syncFromCamera();
            }

            function clampSpherical() {
                spherical.phi = Math.max(controls.minPolarAngle, Math.min(controls.maxPolarAngle, spherical.phi));
                spherical.radius = Math.max(controls.minDistance, Math.min(controls.maxDistance, spherical.radius));
            }

            function update() {
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
                clampSpherical();

                const offset = new THREE.Vector3().setFromSpherical(spherical);
                camera.position.copy(target).add(offset);
                camera.lookAt(target);

                sphericalDelta.theta *= controls.enableDamping ? (1 - controls.dampingFactor) : 0;
                sphericalDelta.phi *= controls.enableDamping ? (1 - controls.dampingFactor) : 0;
            }

            function dispose() {
                domElement.removeEventListener('pointerdown', onPointerDown);
                domElement.removeEventListener('pointermove', onPointerMove);
                domElement.removeEventListener('pointerup', onPointerUp);
                domElement.removeEventListener('pointercancel', onPointerUp);
                domElement.removeEventListener('wheel', onWheel);
            }

            domElement.addEventListener('pointerdown', onPointerDown);
            domElement.addEventListener('pointermove', onPointerMove);
            domElement.addEventListener('pointerup', onPointerUp);
            domElement.addEventListener('pointercancel', onPointerUp);
            domElement.addEventListener('wheel', onWheel, { passive: false });

            syncFromCamera();
            return controls;
        }
    })();
</script>
</body>
</html>